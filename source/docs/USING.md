## Contents

- [Installing](#installing)
- [Dependencies](#dependencies)
- [Architecture](#architecture)
- [Components](#components)
- [Configuring Components](#configuring-components)
- [Running](#running)
- [Resque](#resque)
- [Redis Database Instances](#redis_database_instances)

<a id="installing">&nbsp;</a>

## Installing

The recommended platform to run Flapjack on (other than development) is Ubuntu Precise 64 (Ubuntu 12.04, amd64).
We provide a package for this platform on our [package repository](http://packages.flapjack.io).
The package includes all runtime dependencies, so you shouldn't need to install anything else to get flapjack up and running with a vanilla configuration.

Note also, that if you just want to have a quick play with Flapjack, then why not use [vagrant-flapjack](https://github.com/flapjack/vagrant-flapjack) as this will also take care of creating and setting up an Ubuntu virtual machine and installing flapjack for you.

To install the package on Ubuntu Precise 64, add the deb repo to your apt sources:

```
deb http://packages.flapjack.io/deb precise main
```

eg:

```bash
cat << EOF > /etc/apt/sources.list.d/flapjack.list
deb http://packages.flapjack.io/deb precise main
EOF
```

Then run:

```
sudo apt-get update && sudo apt-get install flapjack
```

You should now find that flapjack and redis have started up. Try visiting the [flapjack web interface](http://localhost:3080).

## Installing as a gem

If you're determined to run Flapjack on an unsupported platform, you can install the Flapjack ruby gem as follows:

``` bash
gem install flapjack
```

<a id="dependencies">&nbsp;</a>
### Dependencies

The Flapjack ruby gem has the following dependencies:

- Ruby >= 1.9
- Redis >= 2.4.15

and the following gems:

* `daemons`
* `oj`
* `redis`
* `eventmachine` (~> 1.0.0)
* `hiredis`
* `em-synchrony` (~> 1.0.2)
* `em-http-request`
* `em-resque`
* `sinatra`
* `rack-fiber_pool`
* `thin`
* `mail`
* `blather`
* `chronic`
* `chronic_duration`

You'll need a working C compiler installed for the gems above with binary components (`eventmachine`, `oj` and `hiredis`).

We want to lower the number of gems that Flapjack relies on -- any pull requests will be gratefully received.

<a id="architecture">&nbsp;</a>
## Architecture

![Flapjack architecture diagram as of 2013-09-27](docs/architecture.png)

```
Check Receivers ---> Executive ---> Gateways
```

**Check Receivers** read check data generated by external programs; Flapjack ships with a Nagios checks receiver, and connectors to other sources of check data could also be written. Checks define the entity they refer to as being in one of three states (`OK`, `WARNING` or `CRITICAL`), are timestamped and can optionally include further data about the reason for the current entity state. The checks are added onto an events queue by the check receivers.

The Flapjack **Executive** reads events from the events queue and determines which contacts should be notified for them. It runs filters to prevent notifications being fired too often for the same check.

Flapjack **Gateways** serve as the public interface to Flapjack. There are *unidirectional* notifiers (e.g. `email` and `sms`, which read notifications from a queue and send them out to registered contacts, there are *bidirectional* notifiers (e.g. `jabber`, `pagerduty`) which do the above and also offer a back-channel for acknowledgements etc., and there are also `web` and `api` gateways for retrieving reporting data, creating maintenance periods, acknowledging checks, etc.

### Processor and Notifier

In the beginning, there was Executive. This has been split into two separte components, *processor* and *notifier*.

Flapjack processor processes events from the *events* list in redis. It does a blocking read on redis so new events are picked off the events list and processed as soon as they created.

When executive decides somebody ought to be notified (for a problem, recovery, or acknowledgement or what-have-you) it generates a job on the *notifications* queue.

Notifier picks up jobs from the *notificaitons* queue, looks up contact information, applies notification rules and per-media intervals and rollup logic, and then creates notification jobs for the appropriate notification gateways.

<a id="components">&nbsp;</a>
## Components

Executables:

  * `flapjack` => starts multiple components ('pikelets') within the one ruby process as specified in the configuration file.
  * `flapjack-nagios-receiver` => reads nagios check output on standard input and places them on the events queue in redis as JSON blobs. Currently unable to be run in-process with `flapjack`
  * `flapjack-nsca-receiver` => reads the nagios' commandfile output and places them on the events queue in redis as JSON blobs. Currently unable to be run in-process with `flapjack`
  * `flapper` => runs a daemon that intermittently listens on port 12345 (one minute on, one minute off, ...)
    to be used for generating heartbeat events for end to end monitoring of flapjack
  * `flapjack-populator` => creates contacts and entities in redis, reading from JSON formatted data files
  * `receive-events` => reads archived events from a separate flapjack environment and adds them to the local events queue for processing
  * `simulate-failed-check` => simulates a failed check by creating a stream of events for flapjack to process

Usage information for each executable is provided below.

Pikelets:

*   `processor` => processes monitoring events off the *events* queue (a redis list) and decides what actions to take (generate notification event, record state changes, etc)
*   `notifier` => processes notification events off the *notifications* queue (a redis list) and works out who to notify, and on which media, and with what kind of notification message. It then creates jobs for the various notification gateways (below)

*   notification gateways
    * `email` => generates email notifications (resque, mail)
    * `sms` => generates sms notifications (resque)
    * `jabber` => connects to an XMPP (jabber) server, sends notifications (to rooms and individuals), handles acknowledgements from jabber users and other commands (blather)
    * `pagerduty` => sends notifications to and accepts acknowledgements from [PagerDuty](http://www.pagerduty.com/) (NB: contacts will need to have a registered PagerDuty account to use this)

*   other gateways
    * `web` => browsable web interface (sinatra, thin)
    * `api` => HTTP API server (sinatra, thin)
    * `oobetet` => "out-of-band" end-to-end testing, used for monitoring other instances of flapjack to ensure that they are running correctly

Pikelets are flapjack components which can be run within the same ruby process, or as separate processes.

The simplest configuration will have one `flapjack` process running processor, notifier, web, and some notification gateways, and one `flapjack-nagios-receiver` process receiving events from Nagios and placing them on the events queue for processing.


<a id="configuring_components">&nbsp;</a>
## Configuring Components

Copy the example config file into place:

```
cp etc/flapjack-config.yaml.example etc/flapjack-config.yaml
```

and then edit the configuration to suit. The value of the environment variable `FLAPJACK_ENV` is used as the configuration key, to choose which of the top-level configuration hashes in the YAML file should be loaded. (The default FLAPJACK_ENV is "development" if there is no environment variable set.)

An example configuration stanza is replicated below, along with comments describing the function of the configuration settings.

```yaml
development:
  pid_file: tmp/pids/flapjack.pid
  log_file: log/flapjack.log
  # whether or not flapjack should run daemonized (using the daemons gem)
  daemonize: no
  redis:
    # the redis server hostname to connect to
    host: 127.0.0.1
    # the redis server port to connect to
    port: 6379
    # the redis database number to use
    db: 13
  processor:
    enabled: yes
    queue: events
    notifier_queue: notifications
    archive_events: true
    events_archive_maxage: 10800
    new_check_scheduled_maintenance_duration: 100 years
    logger:
      level: INFO
      syslog_errors: yes
  notifier:
    enabled: yes
    queue: notifications
    email_queue: email_notifications
    sms_queue: sms_notifications
    jabber_queue: jabber_notifications
    pagerduty_queue: pagerduty_notifications
    notification_log_file: /var/log/flapjack/notification.log
    default_contact_timezone: UTC
    logger:
      level: INFO
      syslog_errors: yes
  nagios-receiver:
    fifo: "/var/cache/nagios3/event_stream.fifo"
    pid_file: "/var/run/flapjack/flapjack-nagios-receiver.pid"
    log_file: "/var/log/flapjack/flapjack-nagios-receiver.log"
  nsca-receiver:
    fifo: "/var/lib/nagios3/rw/nagios.cmd"
    pid_file: "/var/run/flapjack/flapjack-nsca-receiver.pid"
    log_file: "/var/log/flapjack/flapjack-nsca-receiver.log"
  gateways:
    email:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: email_notifications
      logger:
        level: INFO
      smtp_config:
        # these values are passed directly through to EventMachine::Protocols::SmtpClient configuration,
        # and can be omitted if the defaults are acceptable
        host: "localhost"
        port: 25
        domain: 'localhost.localdomain'
        starttls: false
        from: 'flapjack@localhost.localdomain'
        #auth:
        #  type: :plain
        #  username: vera
        #  password: xxxxxxxx
      # location of custom alert templates
      #templates:
      #  rollup_subject.text: '/etc/flapjack/templates/email/rollup_subject.text.erb'
      #  alert_subject.text: '/etc/flapjack/templates/email/alert_subject.text.erb'
      #  rollup.text: '/etc/flapjack/templates/email/rollup.text.erb'
      #  alert.text: '/etc/flapjack/templates/email/alert.text.erb'
      #  rollup.html: '/etc/flapjack/templates/email/rollup.html.erb'
      #  alert.html: '/etc/flapjack/templates/email/alert.html.erb'
    sms:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: sms_notifications
      username: "ermahgerd"
      password: "xxxx"
      logger:
        level: INFO
      # location of custom alert templates
      #templates:
      #  rollup.text: '/etc/flapjack/templates/sms/rollup.text.erb'
      #  alert.text: '/etc/flapjack/templates/sms/alert.text.erb'
    jabber:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: jabber_notifications
      # the jabber server hostname to connect to
      server: "jabber.domain.tld"
      # the jabber server port to connect to
      port: 5222
      # the jabber username to present for signing in
      jabberid: "flapjack@jabber.domain.tld"
      # the jabber password to present for signing in
      password: "good-password"
      # the user alias the pikelet should use
      alias: "flapjack"
      # the Multi-User Chats the pikelet should join and announce to
      rooms:
        - "flapjacktest@conference.jabber.domain.tld"
        - "log@conference.jabber.domain.tld"
      logger:
        level: INFO
      # location of custom alert templates
      #templates:
      #  rollup.text: '/etc/flapjack/templates/jabber/rollup.text.erb'
      #  alert.text: '/etc/flapjack/templates/jabber/alert.text.erb'
    oobetet:
      # whether or not this pikelet should be started
      enabled: yes
      # server, port, jabberid, password, alias, rooms: see the jabber pikelet
      server: "jabber.domain.tld"
      port: 5222
      jabberid: "flapjacktest@jabber.domain.tld"
      password: "nuther-good-password"
      alias: "flapjacktest"
      watched_check: "PING"
      watched_entity: "foo.bar.net"
      max_latency: 300
      pagerduty_contact: "11111111111111111111111111111111"
      rooms:
        - "flapjacktest@conference.jabber.domain.tld"
        - "log@conference.jabber.domain.tld"
      logger:
        level: INFO
    pagerduty:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: pagerduty_notifications
      logger:
        level: INFO
      # location of custom alert templates
      #templates:
      #  alert.text: '/etc/flapjack/templates/pagerduty/alert.text.erb'
    web:
      # whether or not this pikelet should be started
      enabled: yes
      # the port the web server should be run on
      port: 5080
      logger:
        level: INFO
    api:
      # whether or not this pikelet should be started
      enabled: yes
      # the port the API server should be run on
      port: 5081
      logger:
        level: INFO
```


#### Details

##### processor: `new_check_scheduled_maintenance_duration`

This setting controls how long we set scheduled maintenance for new check results. 

Flapjack sets scheduled maintenance on new check results so contacts aren't notified as soon as Flapjack becomes aware of an entity to notify on. This is useful is cases where your monitoring starts checking something before it is completely provisioned, 

For example: 

> CloudFormation starts a cluster of EC2 instances that take 10 minutes to provision, but your monitoring starts checking those EC2 instances 5 minutes into their provisioning. This would result in false-positives from Flapjack, as Flapjack would notify contacts before the instances are fully provisioned. 

The value for this setting is parsed by [Chronic Duration](https://github.com/hpoydar/chronic_duration), so you can specify interesting things like: 

- `12.4 secs`
- `1:20` => 1 minute 20 seconds
- `6 mos 1 day` => 6 months 1 day
- `47 yrs 6 mos and 4d` 
- `two hours and twenty minutes`

You can disable this setting by specifying `0 seconds`. 

The default value for this setting is `100 years`. 

<a id="configuring_nagios">&nbsp;</a>
### Configuring Nagios

You need a Nagios prior to version 3.3 as it introduced [a bug that breaks perfdata output](http://tracker.nagios.org/view.php?id=247) for checks which don't generate performance data (stuff after a | in the check output).

Because this output is omitted, `flapjack-nagios-receiver` is unable to parse event information from Nagios and send it to Flapjack.

There are unconfirmed reports Nagios releases in the 3.4.x series have a fix for the perfdata, however we have not confirmed this. Nagios 4.x *may* also work, however this is also unconfirmed.

We are developing and running against Nagios version 3.2.3 with success.

`nagios.cfg` config file changes:

```text
# modified lines:
enable_notifications=0
host_perfdata_file=/var/cache/nagios3/event_stream.fifo
service_perfdata_file=/var/cache/nagios3/event_stream.fifo
host_perfdata_file_template=[HOSTPERFDATA]\t$TIMET$\t$HOSTNAME$\tHOST\t$HOSTSTATE$\t$HOSTEXECUTIONTIME$\t$HOSTLATENCY$\t$HOSTOUTPUT$\t$HOSTPERFDATA$
service_perfdata_file_template=[SERVICEPERFDATA]\t$TIMET$\t$HOSTNAME$\t$SERVICEDESC$\t$SERVICESTATE$\t$SERVICEEXECUTIONTIME$\t$SERVICELATENCY$\t$SERVICEOUTPUT$\t$SERVICEPERFDATA$
host_perfdata_file_mode=p
service_perfdata_file_mode=p
```

What we're doing here is telling Nagios to generate a line of output for every host and service check into a named pipe. The template lines must be as above so that `flapjack-nagios-receiver` knows what to expect.

All hosts and services (or templates that they use) will need to have process_perf_data enabled on them. (This is a real misnomer, it doesn't mean the performance data will be processed, just that it will be fed to the perfdata output channel, a named pipe in our case.)

Create the named pipe if it doesn't already exist:

    mkfifo -m 0666 /var/cache/nagios3/event_stream.fifo

Note that the templates used in the nagios configuration for service_perfdata_file_template and host_perfdata_file_template must be configured to be exactly as flapjack-nagios-receiver expects otherwise it will drop events that don't match the expected format. The current requrements for the data format that flapjack-nagios-receiver expects from the named pipe is as per the above nagios templates. The following checks are made of each line of textual data found in the pipe, and if any fail the line does not result in an event being created:

The line must:
- split into at least 9 tab-separated words
- contain a unix timestamp in the 2nd word (seconds since epoch) - so just a whole number
- the first word (object type) must contain either `[HOSTPERFDATA]` or `[SERVICEPERFDATA]`.

Currently any error messages about lines that are unable to be read are written to STDOUT.

#### Limitations with the flapjack-nagios-receiver approach

We have seen loss of events with this event transport when the number of events being generated between dumps to the named pipe goes above some threshold. It would appear as though Nagios is overflowing an internal buffer for the performance data between each 10 or 20 second perfdata output flush. This was of the order of thousands of events per flush. It could also have been some other aspect of this transport causing events to be lost.

For this reason, a nagios event broker module - [flapjackfeeder](https://github.com/flapjack/flapjackfeeder) - is being developed to offer an alternative to flapjack-nagios-receiver for high check throughput environments, or potentially a full replacement.

<a id="running">&nbsp;</a>
## Running

There's a collection of executables included. Here's their usage information.

### flapjack
``` text
Usage: flapjack COMMAND [OPTIONS]

Commands
     start                           start flapjack
     stop                            stop flapjack
     restart                         (re)start flapjack
     reload                          reload flapjack configuration
     status                          see if flapjack is running
     version                         display flapjack version and exit
     help                            display this usage info

Options
    -c, --config [PATH]              PATH to the config file to use
    -d, --[no-]daemonize             Daemonize?
    -p, --pidfile [PATH]             PATH to the pidfile to write to
    -l, --logfile [PATH]             PATH to the logfile to write to
    -v, --version                    display flapjack version
```

### flapjack-nagios-receiver
``` text
Usage: flapjack-nagios-receiver COMMAND [OPTIONS]

Commands
     start                           start flapjack-nagios-receiver
     stop                            stop flapjack-nagios-receiver
     restart                         (re)start flapjack-nagios-receiver
     status                          see if flapjack-nagios-receiver is running

Options
    -c, --config [PATH]              PATH to the config file to use
    -f, --fifo FIFO                  Path to the nagios perfdata named pipe
    -d, --[no-]daemonize             Daemonize?
    -p, --pidfile [PATH]             PATH to the pidfile to write to
    -l, --logfile [PATH]             PATH to the logfile to write to
    -h, --help                       Show this usage message

Required Nagios Configuration Changes
-------------------------------------

flapjack-nagios-receiver reads events from a named pipe written to by Nagios..                                                              The named pipe needs creating, and Nagios needs to be told to write performance.
data output to it.

To create the named pipe:

  mkfifo -m 0666 /var/cache/nagios3/event_stream.fifo

nagios.cfg changes:

  # modified lines:
  enable_notifications=0
  host_perfdata_file=/var/cache/nagios3/event_stream.fifo
  service_perfdata_file=/var/cache/nagios3/event_stream.fifo
  host_perfdata_file_template=[HOSTPERFDATA]\t$TIMET$\t$HOSTNAME$\tHOST\t$HOSTSTATE$\t$HOSTEXECUTIONTIME$\t$HOSTLATENCY$\t$HOSTOUTPUT$\t$HOSTPERFDATA$
  service_perfdata_file_template=[SERVICEPERFDATA]\t$TIMET$\t$HOSTNAME$\t$SERVICEDESC$\t$SERVICESTATE$\t$SERVICEEXECUTIONTIME$\t$SERVICELATENCY$\t$SERVICEOUTPUT$\t$SERVICEPERFDATA$
  host_perfdata_file_mode=p
  service_perfdata_file_mode=p

Details on the wiki: docs/USING#configuring-nagios
```
Examples:
``` bash
flapjack-nagios-receiver start --config /etc/flapjack/flapjack-config.yaml --fifo /path/to/nagios/perfdata.fifo
flapjack-nagios-receiver status
flapjack-nagios-receiver restart --config /etc/flapjack/flapjack-config.yaml --fifo /path/to/nagios/perfdata.fifo
flapjack-nagios-receiver stop
```

The redis database connection information is read out of the specified flapjack configuration file, for the current FLAPJACK_ENV environment.

See the [Configuring Nagios](#configuring_nagios) section above for more information.

### flapper
``` text
Usage: flapper COMMAND [OPTIONS]

Commands
     start                           start flapper
     stop                            stop flapper
     restart                         (re)start flapper
     status                          see if flapper is running

Options
    -d, --[no-]daemonize             Daemonize?
    -p, --pidfile [PATH]             PATH to the pidfile to write to
    -l, --logfile [PATH]             PATH to the logfile to write to
    -b, --bind-ip [ADDRESS]          ADDRESS (IPv4 or IPv6) for flapper to bind to
```

### flapjack-populator
``` text
Usage: flapjack-populator COMMAND [OPTIONS]

Commands:
     import-entities
     import-contacts
     purge-events    purge queued monitoring events

Options
    -c, --config [PATH]              PATH to the config file to use
    -f, --from [FILE]                path to the FILE to import
```

### receive-events
``` text
Usage: receive-events COMMAND [OPTIONS]

Commands
     help

Options
    -c, --config [PATH]              PATH to the config file to use
    -s, --source URL                 URL of source redis database, eg redis://localhost:6379/0
    -f, --follow                     keep reading events as they are archived on the source
    -a, --all                        replay all archived events from the source
    -l, --last COUNT                 replay the last COUNT events from the source
    -t, --time TIME                  replay all events archived on the source since TIME
```

### simulate-failed-check
``` text
Usage: simulate-failed-check COMMAND [OPTIONS]

Commands
     fail-and-recover
     fail

Options
    -c, --config [PATH]              PATH to the config file to use
    -t, --time MINUTES               MINUTES to generate failure events for
    -i, --interval SECONDS           SECONDS between events, can be decimal eg 0.1 (10)
    -e, --entity ENTITY              ENTITY to generate failure events for ('foo-app-01')
    -k, --check CHECK                CHECK to generate failure events for ('HTTP')
    -s, --state STATE                optional STATE to generate failure events with ('CRITICAL')
```

<a id="resque">&nbsp;</a>
## Resque

### Resque Workers

We're using [Resque](https://github.com/resque/resque) to queue email and sms notifications generated by flapjack-executive. The queues are named as follows:
- email_notifications
- sms_notifications

Note that using the flapjack-config.yaml file you can have flapjack start the resque workers in-process. Or you can run them standalone with the `rake resque:work` command as follows.

One resque worker that processes both queues (but prioritises SMS above email) can be started as follows:

    QUEUE=sms_notifications,email_notifications VERBOSE=1 be rake resque:work

resque sets the command name so grep'ing ps output for `rake` or `ruby` will NOT find resque processes. Search instead for `resque`. (and remember the 'q').

To background it you can add `BACKGROUND=yes`. Useful documentation is available in [Resque's README](https://github.com/resque/resque/blob/master/README.markdown)

### Resque Queue Management with resque-web

If you need to inspect or purge the queues managed by resque you'll want to start up an instance of resque-web. This will by default connect to redis database 0 which is fine for production but in development you'll need to specify database id 13 (or whatever you have it set to in the flapjack config) eg:

```bash
resque-web -p 4082 -r localhost:6379:13
```
This will start a resque-web instance listening on port 4082, connecting to the redis server on localhost port 6379, and selecting database 13.

<a id="redis_database_instances">&nbsp;</a>
## Redis Database Instances

We use the following redis database numbers by convention:

* 0 => production
* 6 => quickstart
* 13 => development
* 14 => testing
