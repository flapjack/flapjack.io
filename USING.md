## Contents

- [Installing](#installing)
- [Dependencies](#dependencies)
- [Architecture](#architecture)
- [Components](#components)
- [Configuring Components](#configuring_components)
- [Running](#running)
- [Resque](#resque)
- [Redis Database Instances](#redis_database_instances)

<a id="installing">&nbsp;</a>
## Installing

Install the Flapjack gem:

``` bash
gem install flapjack
```


<a id="dependencies">&nbsp;</a>
## Dependencies

- Ruby >= 1.9
- Redis >= 2.4.15

and the following gems:

* `daemons`
* `oj`
* `redis`
* `eventmachine` (~> 1.0.0)
* `hiredis`
* `em-synchrony` (~> 1.0.2)
* `em-http-request`
* `em-resque`
* `sinatra`
* `rack-fiber_pool`
* `haml`
* `thin`
* `mail`
* `blather`
* `chronic`
* `chronic_duration`

You'll need a working C compiler installed for the gems above with binary components (`eventmachine`, `oj` and `hiredis`).

We want to lower the number of gems that Flapjack relies on -- any pull requests will be gratefully received.

<a id="architecture">&nbsp;</a>
## Architecture

![Flapjack architecture diagram as of 2013-09-27](https://raw.github.com/wiki/flpjck/flapjack/architecture.png)

```
Check Receivers ---> Executive ---> Gateways
```

**Check Receivers** read check data generated by external programs; Flapjack ships with a Nagios checks receiver, and connectors to other sources of check data could also be written. Checks define the entity they refer to as being in one of three states (`OK`, `WARNING` or `CRITICAL`), are timestamped and can optionally include further data about the reason for the current entity state. The checks are added onto an events queue by the check receivers.

The Flapjack **Executive** reads events from the events queue and determines which contacts should be notified for them. It runs filters to prevent notifications being fired too often for the same check.

Flapjack **Gateways** serve as the public interface to Flapjack. There are *unidirectional* notifiers (e.g. `email` and `sms`, which read notifications from a queue and send them out to registered contacts, there are *bidirectional* notifiers (e.g. `jabber`, `pagerduty`) which do the above and also offer a back-channel for acknowledgements etc., and there are also `web` and `api` gateways for retrieving reporting data, creating maintenance periods, acknowledging checks, etc.

### Processor and Notifier

In the beginning, there was Executive. This has been split into two separte components, *processor* and *notifier*.

Flapjack processor processes events from the *events* list in redis. It does a blocking read on redis so new events are picked off the events list and processed as soon as they created.

When executive decides somebody ought to be notified (for a problem, recovery, or acknowledgement or what-have-you) it generates a job on the *notifications* queue.

Notifier picks up jobs from the *notificaitons* queue, looks up contact information, applies notification rules and per-media intervals and rollup logic, and then creates notification jobs for the appropriate notification gateways.

<a id="components">&nbsp;</a>
## Components

Executables:

  * `flapjack` => starts multiple components ('pikelets') within the one ruby process as specified in the configuration file.
  * `flapjack-nagios-receiver` => reads nagios check output on standard input and places them on the events queue in redis as JSON blobs. Currently unable to be run in-process with `flapjack`
  * `flapper` => runs a daemon that intermittently listens on port 12345 (one minute on, one minute off, ...)
    to be used for generating heartbeat events for end to end monitoring of flapjack
  * `flapjack-populator` => creates contacts and entities in redis, reading from JSON formatted data files
  * `receive-events` => reads archived events from a separate flapjack environment and adds them to the local events queue for processing
  * `simulate-failed-check` => simulates a failed check by creating a stream of events for flapjack to process

Usage information for each executable is provided below.

Pikelets:

*   `processor` => processes monitoring events off the *events* queue (a redis list) and decides what actions to take (generate notification event, record state changes, etc)
*   `notifier` => processes notification events off the *notifications* queue (a redis list) and works out who to notify, and on which media, and with what kind of notification message. It then creates jobs for the various notification gateways (below)

*   notification gateways
    * `email` => generates email notifications (resque, mail)
    * `sms` => generates sms notifications (resque)
    * `jabber` => connects to an XMPP (jabber) server, sends notifications (to rooms and individuals), handles acknowledgements from jabber users and other commands (blather)
    * `pagerduty` => sends notifications to and accepts acknowledgements from [PagerDuty](http://www.pagerduty.com/) (NB: contacts will need to have a registered PagerDuty account to use this)

*   other gateways
    * `web` => browsable web interface (sinatra, thin)
    * `api` => HTTP API server (sinatra, thin)
    * `oobetet` => "out-of-band" end-to-end testing, used for monitoring other instances of flapjack to ensure that they are running correctly

Pikelets are flapjack components which can be run within the same ruby process, or as separate processes.

The simplest configuration will have one `flapjack` process running processor, notifier, web, and some notification gateways, and one `flapjack-nagios-receiver` process receiving events from Nagios and placing them on the events queue for processing.


<a id="configuring_components">&nbsp;</a>
## Configuring Components

Copy the example config file into place:

```
cp etc/flapjack-config.yaml.example etc/flapjack-config.yaml
```

and then edit the configuration to suit. The value of the environment variable `FLAPJACK_ENV` is used as the configuration key, to choose which of the top-level configuration hashes in the YAML file should be loaded. (The default FLAPJACK_ENV is "development" if there is no environment variable set.)

An example configuration stanza is replicated below, along with comments describing the function of the configuration settings.

```yaml
development:
  pid_file: tmp/pids/flapjack.pid
  log_file: log/flapjack.log
  # whether or not flapjack should run daemonized (using the daemons gem)
  daemonize: no
  redis:
    # the redis server hostname to connect to
    host: 127.0.0.1
    # the redis server port to connect to
    port: 6379
    # the redis database number to use
    db: 13
  executive:
    # whether or not this pikelet should be started
    enabled: yes
    email_queue: email_notifications
    sms_queue: sms_notifications
    jabber_queue: jabber_notifications
    pagerduty_queue: pagerduty_notifications
    notification_log_file: log/flapjack-notification.log
    # contacts with no timezone string specified will be considered to be in this timezone:
    default_contact_timezone: Australia/Broken_Hill
    # whether to archive events as they are processed
    archive_events: true
    # how long to retain the hourly buckets of archived keys (via redis expiry)
    events_archive_maxage: 3600
    logger:
      level: INFO
  gateways:
    email:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: email_notifications
      logger:
        level: INFO
      smtp_config:
        # these values are passed directly through to EventMachine::Protocols::SmtpClient configuration,
        # and can be omitted if the defaults are acceptable
        host: "localhost"
        port: 25
        domain: 'localhost.localdomain'
        starttls: false
        from: 'flapjack@localhost.localdomain'
        #auth:
        #  type: :plain
        #  username: vera
        #  password: xxxxxxxx
    sms:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: sms_notifications
      username: "ermahgerd"
      password: "xxxx"
      logger:
        level: INFO
    jabber:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: jabber_notifications
      # the jabber server hostname to connect to
      server: "jabber.domain.tld"
      # the jabber server port to connect to
      port: 5222
      # the jabber username to present for signing in
      jabberid: "flapjack@jabber.domain.tld"
      # the jabber password to present for signing in
      password: "good-password"
      # the user alias the pikelet should use
      alias: "flapjack"
      # the Multi-User Chats the pikelet should join and announce to
      rooms:
        - "flapjacktest@conference.jabber.domain.tld"
        - "log@conference.jabber.domain.tld"
      logger:
        level: INFO
    oobetet:
      # whether or not this pikelet should be started
      enabled: yes
      # server, port, jabberid, password, alias, rooms: see the jabber pikelet
      server: "jabber.domain.tld"
      port: 5222
      jabberid: "flapjacktest@jabber.domain.tld"
      password: "nuther-good-password"
      alias: "flapjacktest"
      watched_check: "PING"
      watched_entity: "foo.bar.net"
      max_latency: 300
      pagerduty_contact: "11111111111111111111111111111111"
      rooms:
        - "flapjacktest@conference.jabber.domain.tld"
        - "log@conference.jabber.domain.tld"
      logger:
        level: INFO
    pagerduty:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: pagerduty_notifications
      logger:
        level: INFO
    web:
      # whether or not this pikelet should be started
      enabled: yes
      # the port the web server should be run on
      port: 5080
      logger:
        level: INFO
    api:
      # whether or not this pikelet should be started
      enabled: yes
      # the port the API server should be run on
      port: 5081
      logger:
        level: INFO
```


### Configuring Nagios

You need a Nagios prior to version 3.3 as this breaks perfdata output for checks which don't generate performance data (stuff after a | in the check output). We are developing and running against Nagios version 3.2.3 with success.

`nagios.cfg` config file changes:

```
# modified lines:
enable_notifications=0
host_perfdata_file=/var/cache/nagios3/event_stream.fifo
service_perfdata_file=/var/cache/nagios3/event_stream.fifo
host_perfdata_file_template=[HOSTPERFDATA]\t$TIMET$\t$HOSTNAME$\tHOST\t$HOSTSTATE$\t$HOSTEXECUTIONTIME$\t$HOSTLATENCY$\t$HOSTOUTPUT$\t$HOSTPERFDATA$
service_perfdata_file_template=[SERVICEPERFDATA]\t$TIMET$\t$HOSTNAME$\t$SERVICEDESC$\t$SERVICESTATE$\t$SERVICEEXECUTIONTIME$\t$SERVICELATENCY$\t$SERVICEOUTPUT$\t$SERVICEPERFDATA$
host_perfdata_file_mode=p
service_perfdata_file_mode=p
```

What we're doing here is telling Nagios to generate a line of output for every host and service check into a named pipe. The template lines must be as above so that `flapjack-nagios-receiver` knows what to expect.

All hosts and services (or templates that they use) will need to have process_perf_data enabled on them. (This is a real misnomer, it doesn't mean the performance data will be processed, just that it will be fed to the perfdata output channel, a named pipe in our case.)

Create the named pipe if it doesn't already exist:

    mkfifo -m 0666 /var/cache/nagios3/event_stream.fifo


<a id="running">&nbsp;</a>
## Running

There's a collection of executables included. Here's their usage information.

### flapjack
```
Usage: flapjack COMMAND [OPTIONS]

Commands
     start                           start flapjack
     stop                            stop flapjack
     restart                         (re)start flapjack
     reload                          reload flapjack configuration
     status                          see if flapjack is running
     version                         display flapjack version and exit
     help                            display this usage info

Options
    -c, --config [PATH]              PATH to the config file to use
    -d, --[no-]daemonize             Daemonize?
    -p, --pidfile [PATH]             PATH to the pidfile to write to
    -l, --logfile [PATH]             PATH to the logfile to write to
    -v, --version                    display flapjack version
```

### flapjack-nagios-receiver
```
Usage: flapjack-nagios-receiver COMMAND [OPTIONS]

Commands
     start                           start flapjack-nagios-receiver
     stop                            stop flapjack-nagios-receiver
     restart                         (re)start flapjack-nagios-receiver
     status                          see if flapjack-nagios-receiver is running

Options
    -c, --config [PATH]              PATH to the config file to use
    -f, --fifo FIFO                  Path to the nagios perfdata named pipe
    -d, --[no-]daemonize             Daemonize?
    -p, --pidfile [PATH]             PATH to the pidfile to write to
    -l, --logfile [PATH]             PATH to the logfile to write to
```
Examples:
```
flapjack-nagios-receiver start --config /etc/flapjack/flapjack-config.yaml --fifo /path/to/nagios/perfdata.fifo
flapjack-nagios-receiver status
flapjack-nagios-receiver restart --config /etc/flapjack/flapjack-config.yaml --fifo /path/to/nagios/perfdata.fifo
flapjack-nagios-receiver stop
```

The redis database connection information is read out of the specified flapjack configuration file, for the current FLAPJACK_ENV environment.


### flapper
```
Usage: flapper COMMAND [OPTIONS]

Commands
     start                           start flapper
     stop                            stop flapper
     restart                         (re)start flapper
     status                          see if flapper is running

Options
    -d, --[no-]daemonize             Daemonize?
    -p, --pidfile [PATH]             PATH to the pidfile to write to
    -l, --logfile [PATH]             PATH to the logfile to write to
    -b, --bind-ip [ADDRESS]          ADDRESS (IPv4 or IPv6) for flapper to bind to
```

### flapjack-populator
```
TODO
```

### receive-events
```
Usage: receive-events COMMAND [OPTIONS]

Commands
     help

Options
    -c, --config [PATH]              PATH to the config file to use
    -s, --source URL                 URL of source redis database, eg redis://localhost:6379/0
    -f, --follow                     keep reading events as they are archived on the source
    -a, --all                        replay all archived events from the source
    -l, --last COUNT                 replay the last COUNT events from the source
    -t, --time TIME                  replay all events archived on the source since TIME
```

### simulate-failed-check
```
Usage: simulate-failed-check COMMAND [OPTIONS]

Commands
     fail-and-recover
     fail

Options
    -c, --config [PATH]              PATH to the config file to use
    -t, --time MINUTES               MINUTES to generate failure events for
    -e, --entity ENTITY              ENTITY to generate failure events for ('foo-app-01')
    -k, --check CHECK                CHECK to generate failure events for ('HTTP')
    -s, --state STATE                optional STATE to generate failure events with ('CRITICAL')
```


### flapjack-nagios-receiver

    flapjack-nagios-receiver COMMAND [OPTIONS]

    Commands
         start                           start flapjack-nagios-receiver
         stop                            stop flapjack-nagios-receiver
         restart                         (re)start flapjack-nagios-receiver
         status                          see if flapjack-nagios-receiver is running

    Options
        -c, --config [PATH]              PATH to the config file to use
        -f, --fifo FIFO                  Path to the nagios perfdata named pipe
        -d, --[no-]daemonize             Daemonize?
        -p, --pidfile [PATH]             PATH to the pidfile to write to
        -l, --logfile [PATH]             PATH to the logfile to write to

<a id="resque">&nbsp;</a>
## Resque

### Resque Workers

We're using [Resque](https://github.com/defunkt/resque) to queue email and sms notifications generated by flapjack-executive. The queues are named as follows:
- email_notifications
- sms_notifications

Note that using the flapjack-config.yaml file you can have flapjack start the resque workers in-process. Or you can run them standalone with the `rake resque:work` command as follows.

One resque worker that processes both queues (but prioritises SMS above email) can be started as follows:

    QUEUE=sms_notifications,email_notifications VERBOSE=1 be rake resque:work

resque sets the command name so grep'ing ps output for `rake` or `ruby` will NOT find resque processes. Search instead for `resque`. (and remember the 'q').

To background it you can add `BACKGROUND=yes`. Useful documentation is available in [Resque's README](https://github.com/defunkt/resque/blob/master/README.markdown)

### Resque Queue Management with resque-web

If you need to inspect or purge the queues managed by resque you'll want to start up an instance of resque-web. This will by default connect to redis database 0 which is fine for production but in development you'll need to specify database id 13 (or whatever you have it set to in the flapjack config) eg:

```bash
resque-web -p 4082 -r localhost:6379:13
```
This will start a resque-web instance listening on port 4082, connecting to the redis server on localhost port 6379, and selecting database 13.

<a id="redis_database_instances">&nbsp;</a>
## Redis Database Instances

We use the following redis database numbers by convention:

* 0 => production
* 6 => quickstart
* 13 => development
* 14 => testing

