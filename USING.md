## Contents

- [Installing](#installing)
- [Dependencies](#dependencies)
- [Architecture](#architecture)
- [Components](#components)
- [Configuring Components](#configuring_components)
- [Running](#running)

<a id="installing">&nbsp;</a>
## Installing

Install the Flapjack gem:

    sudo gem install flapjack


<a id="dependencies">&nbsp;</a>
## Dependencies

- Ruby >= 1.9
- Redis >= 2.4.15
- yajl

and the following gems:

* `daemons`
* `log4r`
* `yajl-ruby`
* `redis`
* `eventmachine` (~> 1.0.0)
* `hiredis`
* `em-synchrony` (~> 1.0.2)
* `em-http-request`
* `em-resque`
* `sinatra`
* `rack-fiber_pool`
* `haml`
* `thin`
* `mail`
* `blather`
* `chronic`
* `chronic_duration`

You'll need a working C compiler installed for the gems above with binary components (`eventmachine`, `yajl-ruby` and `hiredis`).

We want to lower the number of gems that Flapjack relies on -- any pull requests will be gratefully received.

<a id="architecture">&nbsp;</a>
## Architecture

  Check Receivers ---> Executive ---> Gateways

**Check Receivers** read check data generated by external programs; Flapjack ships with a Nagios checks receiver, and connectors to other sources of check data could also be written. Checks define the entity they refer to as being in one of three states (`OK`, `WARNING` or `CRITICAL`), are timestamped and can optionally include further data about the reason for the current entity state. The checks are added onto an events queue by the check receivers.

The Flapjack **Executive** reads events from the events queue and determines which contacts should be notified for them. It runs filters to prevent notifications being fired too often for the same check.

Flapjack **Gateways** serve as the public interface to Flapjack. There are *unidirectional* notifiers (e.g. `email` and `sms`, which read notifications from a queue and send them out to registered contacts, there are *bidirectional* notifiers (e.g. `jabber`, `pagerduty`) which do the above and also offer a back-channel for acknowledgements etc., and there are also `web` and `api` gateways for retrieving reporting data, creating maintenance periods, acknowledging checks, etc.

<a id="components">&nbsp;</a>
## Components

Executables:

  * `flapjack` => starts multiple components ('pikelets') within the one ruby process as specified in the configuration file.
  * `flapjack-nagios-receiver` => reads nagios check output on standard input and places them on the events queue in redis as JSON blobs. Currently unable to be run in-process with `flapjack`
  * `flapper` => runs a daemon that intermittently listens on port 12345 (one minute on, one minute off, ...)
    to be used for generating heartbeat events for end to end monitoring of flapjack

There are more executables in the bin directory (FIXME describe them here).

Pikelets:

*   `executive` => processes events off a queue (a redis list) and decides what actions to take (alert, record state changes, etc)

*   gateways
    * `email` => generates email notifications (resque, mail)
    * `sms` => generates sms notifications (resque)
    * `jabber` => connects to an XMPP (jabber) server, sends notifications (to rooms and individuals), handles acknowledgements from jabber users and other commands (blather)
    * `pagerduty` => sends notifications to and accepts acknowledgements from [PagerDuty](http://www.pagerduty.com/) (NB: you will need to have a registered PagerDuty account to use this)
    * `web` => browsable web interface (sinatra, thin)
    * `api` => HTTP API server (sinatra, thin)
    * `oobetet` => "out-of-band" end-to-end testing, used for monitoring other instances of flapjack to ensure that they are running correctly

Pikelets are flapjack components which can be run within the same ruby process, or as separate processes.

The simplest configuration will have one `flapjack` process running executive, web, and some notification gateways, and one `flapjack-nagios-receiver` process receiving events from Nagios and placing them on the events queue for processing by executive.




<a id="configuring_components">&nbsp;</a>
## Configuring Components

Copy the example config file into place:

```
cp etc/flapjack-config.yaml.example etc/flapjack-config.yaml
```

and then edit the configuration to suit. The value of the environment variable `FLAPJACK_ENV` is used as the configuration key, to choose which of the top-level configuration hashes in the YAML file should be loaded. (The default FLAPJACK_ENV is "development" if there is no environment variable set.)

An example configuration stanza is replicated below, along with comments describing the function of the configuration settings.

```yaml
development:
  pid_file: tmp/pids/flapjack.pid
  log_file: log/flapjack.log
  # whether or not flapjack should run daemonized (using the daemons gem)
  daemonize: no
  redis:
    # the redis server hostname to connect to
    host: 127.0.0.1
    # the redis server port to connect to
    port: 6379
    # the redis database number to use
    db: 13
  executive:
    # whether or not this pikelet should be started
    enabled: yes
    email_queue: email_notifications
    sms_queue: sms_notifications
    jabber_queue: jabber_notifications
    pagerduty_queue: pagerduty_notifications
    notification_log_file: log/flapjack-notification.log
    logger:
      level: INFO
  gateways:
    email:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: email_notifications
      logger:
        level: INFO
      smtp_config:
        # these values are passed directly through to the mail gem's SMTP configuration,
        # and can be omitted if the defaults are acceptable
        port: 25
        address: "localhost"
        domain: 'localhost.localdomain'
        user_name: nil
        password: nil
        authentication: nil
        enable_starttls_auto: true
    sms:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: sms_notifications
      username: "ermahgerd"
      password: "xxxx"
      logger:
        level: INFO
    jabber:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: jabber_notifications
      # the jabber server hostname to connect to
      server: "jabber.domain.tld"
      # the jabber server port to connect to
      port: 5222
      # the jabber username to present for signing in
      jabberid: "flapjack@jabber.domain.tld"
      # the jabber password to present for signing in
      password: "good-password"
      # the user alias the pikelet should use
      alias: "flapjack"
      # the Multi-User Chats the pikelet should join and announce to
      rooms:
        - "flapjacktest@conference.jabber.domain.tld"
        - "log@conference.jabber.domain.tld"
      logger:
        level: INFO
    oobetet:
      # whether or not this pikelet should be started
      enabled: yes
      # server, port, jabberid, password, alias, rooms: see the jabber pikelet
      server: "jabber.domain.tld"
      port: 5222
      jabberid: "flapjacktest@jabber.domain.tld"
      password: "nuther-good-password"
      alias: "flapjacktest"
      watched_check: "PING"
      watched_entity: "foo.bar.net"
      max_latency: 300
      pagerduty_contact: "11111111111111111111111111111111"
      rooms:
        - "flapjacktest@conference.jabber.domain.tld"
        - "log@conference.jabber.domain.tld"
      logger:
        level: INFO
    pagerduty:
      # whether or not this pikelet should be started
      enabled: yes
      # the redis queue the pikelet will look for notifications on
      queue: pagerduty_notifications
      logger:
        level: INFO
    web:
      # whether or not this pikelet should be started
      enabled: yes
      # the port the web server should be run on
      port: 5080
      logger:
        level: INFO
    api:
      # whether or not this pikelet should be started
      enabled: yes
      # the port the API server should be run on
      port: 5081
      logger:
        level: INFO
```


### Configuring Nagios

You need a Nagios prior to version 3.3 as this breaks perfdata output for checks which don't generate performance data (stuff after a | in the check output). We are developing and running against Nagios version 3.2.3 with success.

`nagios.cfg` config file changes:

```
# modified lines:
enable_notifications=0
host_perfdata_file=/var/cache/nagios3/event_stream.fifo
service_perfdata_file=/var/cache/nagios3/event_stream.fifo
host_perfdata_file_template=[HOSTPERFDATA]\t$TIMET$\t$HOSTNAME$\tHOST\t$HOSTSTATE$\t$HOSTEXECUTIONTIME$\t$HOSTLATENCY$\t$HOSTOUTPUT$\t$HOSTPERFDATA$
service_perfdata_file_template=[SERVICEPERFDATA]\t$TIMET$\t$HOSTNAME$\t$SERVICEDESC$\t$SERVICESTATE$\t$SERVICEEXECUTIONTIME$\t$SERVICELATENCY$\t$SERVICEOUTPUT$\t$SERVICEPERFDATA$
host_perfdata_file_mode=p
service_perfdata_file_mode=p
```

What we're doing here is telling Nagios to generate a line of output for every host and service check into a named pipe. The template lines must be as above so that `flapjack-nagios-receiver` knows what to expect.

All hosts and services (or templates that they use) will need to have process_perf_data enabled on them. (This is a real misnomer, it doesn't mean the performance data will be processed, just that it will be fed to the perfdata output channel, a named pipe in our case.)

Create the named pipe if it doesn't already exist:

    mkfifo -m 0666 /var/cache/nagios3/event_stream.fifo


<a id="running">&nbsp;</a>
## Running

    flapjack COMMAND [OPTIONS]

    Commands
         start                           start flapjack
         stop                            stop flapjack
         restart                         (re)start flapjack
         reload                          reload flapjack configuration
         status                          see if flapjack is running

    Options
        -c, --config [PATH]              PATH to the config file to use
        -d, --[no-]daemonize             Daemonize?
        -p, --pidfile [PATH]             PATH to the pidfile to write to
        -l, --logfile [PATH]             PATH to the logfile to write to

The command line options override whatever is set in the config file for these configuration items.

-h or --help can be given to show the above usage information.

### flapjack-nagios-receiver

    flapjack-nagios-receiver COMMAND [OPTIONS]

    Commands
         start                           start flapjack-nagios-receiver
         stop                            stop flapjack-nagios-receiver
         restart                         (re)start flapjack-nagios-receiver
         status                          see if flapjack-nagios-receiver is running

    Options
        -c, --config [PATH]              PATH to the config file to use
        -f, --fifo FIFO                  Path to the nagios perfdata named pipe
        -d, --[no-]daemonize             Daemonize?
        -p, --pidfile [PATH]             PATH to the pidfile to write to
        -l, --logfile [PATH]             PATH to the logfile to write to

Examples:
```
flapjack-nagios-receiver-control start --config /etc/flapjack/flapjack-config.yaml --fifo /path/to/nagios/perfdata.fifo
flapjack-nagios-receiver-control status
flapjack-nagios-receiver-control restart --config /etc/flapjack/flapjack-config.yaml --fifo /path/to/nagios/perfdata.fifo
flapjack-nagios-receiver-control stop
```
-h or --help can be given to show the above usage information.

Currently, only the redis database connection information is read out of the specified flapjack configuration file, for the current FLAPJACK_ENV environment.

### executive

Flapjack executive processes events from the 'events' list in redis. It does a blocking read on redis so new events are picked off the events list and processed as soon as they created.

When executive decides somebody ought to be notified (for a problem, recovery, or acknowledgement or what-have-you) it looks up contact information and then creates a notification job on one of the notification queues (eg sms_notifications) in rescue, or via the jabber_notifications or pagerduty_notifications redis lists which are processed by the jabber and pagerduty gateways respectively.


### Resque Workers

We're using [Resque](https://github.com/defunkt/resque) to queue email and sms notifications generated by flapjack-executive. The queues are named as follows:
- email_notifications
- sms_notifications

Note that using the flapjack-config.yaml file you can have flapjack start the resque workers in-process. Or you can run them standalone with the `rake resque:work` command as follows.

One resque worker that processes both queues (but prioritises SMS above email) can be started as follows:

    QUEUE=sms_notifications,email_notifications VERBOSE=1 be rake resque:work

resque sets the command name so grep'ing ps output for `rake` or `ruby` will NOT find resque processes. Search instead for `resque`. (and remember the 'q').

To background it you can add `BACKGROUND=yes`. Useful documentation is available in [Resque's README](https://github.com/defunkt/resque/blob/master/README.markdown)

### Resque Queue Management with resque-web

If you need to inspect or purge the queues managed by resque you'll want to start up an instance of resque-web. This will by default connect to redis database 0 which is fine for production but in development you'll need to specify database id 13 (or whatever you have it set to in the flapjack config) eg:

```bash
resque-web -p 4082 -r localhost:6379:13
```
This will start a resque-web instance listening on port 4082, connecting to the redis server on localhost port 6379, and selecting database 13.

### Redis Database Instances

We use the following redis database numbers by convention:

* 0 => production
* 6 => quickstart
* 13 => development
* 14 => testing

